# Java03

> 자바의 정석 ch3



## 연산자

- 연산자 : 연산을 수행하는 기호
- 피연산자 : 연산자의 연산 수행 대상



#### 연산자의 종류

- 산술 연산자
  - +, -, *, /, %
- 비교 연산자
  - <, <=, >, >=, ==, !=
- 논리 연산자
  - &&, ||, !
- 대입 연산자
  - =
- 기타
  - (type), ?:, instanceof



#### 연산자의 우선순위

> 상식적으로 생각하라. 우리는 이미 다 알고 있다.

- 산술>비교>논리>대입. 대입은 제일 마지막에 수행
- 단항>이항>삼항. 단항 연산자의 우선순위가 이항 연산자보다 높다



#### 연산자의 결합규칙

> 대입과 단항 연산자를 제외하면, 모두 연산의 진행방향은 왼쪽 => 오른쪽



#### 증감 연산자

- 증가 연산자
- 감소 연산자
- 타입
  - 전위형 : 값이 참조되기 전에 증가시킨다
    - j = ++i;
  - 후위형 : 값이 참조된 후에 증가시킨다
    - j = i++;
  - 증감 연산자가 독립적으로 사용된 경우, 전위형과 후위형의 차이가 없다



#### 부호 연산자

- '-'는 피연산자의 부호를 반대로 변경
- '+'는 아무런 일도 하지 않는다(실제 사용X)



#### 형변환 연산자

> 변수 또는 상수의 타입을 다른 타입으로 변환하는 것

```java
double d = 85.4;
int score = (int)d; // 85

(char)65 // 'A'
(int)'A' // 65
(int)1.6f // 1
(float)10 // 10.0f
```

- 자동 형변환

  ```java
  float f = 1234; // int 타입의 값을 float타입의 변수에 저장
  int i = 3.14f; // 에러(넓은 애를 넣었기 때문)(값 손실 발생)
  int i = (int)3.14f; // 이러면 에러 안남	
  ```

  - 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환된다
  - byte b = 100;
    - 이건 가능
    - byte의 범위가 -128~127이므로 100을 집어넣어도 값손실이 없다는 것을 컴파일러가 알고 있음
  - int i = 100; byte b = i;
    - 이건 불가능



#### 사칙 연산자

- 산술 변환

  - 연산 전에 피연산자의 타입을 일치시키는 것
    1. 두 연산자의 타입을 같게 일치시킨다(보다 큰 타입으로 일치)
       - long + int => long
       - float + int => float
    2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다
       - byte, short, char
  - '0'=48, '1'=49

  ```java
  int a = 1_000_000;
  int b = 2_000_000;
      
  long c = a * b; // 하면 overflow 발생, 이상한 음수가 나옴
  long c = long(a) * b; // a나 b에 long을 씌워 줘야 함
  ```



#### 반올림 - Math.round()

- 실수를 소수점 첫째자리에서 반올림한 정수를 반환

  ```java
  double pi = 3.141592;
  
  pi; // 3.141592
  pi*1000; // 3141.592
  Math.round(pi*1000); // 3142
  Math.round(pi*1000)/1000; // 3
  Math.round(pi*1000)/1000.0; // 3.142
  (int)(pi*1000)/1000.0; // 3.141
  ```



#### 나머지 연산자 %

- 오른쪽 피연산자로 나누고 남은 나머지를 반환
- 피연산자로 정수만 받음
- 부호는 무시



#### 비교 연산자

- 두 피연산자를 비교해서 true 또는 false 반환

- 문자열 비교에는 == 대신 equals()를 사용해야 한다(정확한 판단 위해)

  - str1.equals(str2);

    ```java
    String str1 = new String("abc");
    String str2 = new String("abc");
    str1 == str2; // false
    str1.equals(str2); // true
    ```



#### 논리 연산자

- || (OR 결합)
  - 피연산자 중 어느 한 쪽이 true면 true
- && (AND결합)
  - 양쪽 모두 true여야 true
  - 10 < x < 20 => 안됨
  - 10 < x && x < 20 => 이렇게 써야함
- 논리 부정 연산자 !
  - python/js와 비슷



#### 조건 연산자

> js의 그것과 비슷

- ? :
- result = (x > y) > x : y ;



#### 대입 연산자

> 오른쪽 피연산자의 값을 왼쪽 피연산자에 저장 후 저장된 값을 반환

- System.out.println(x = 3); => 3

- lvalue = rvalue

- lvalue는 값을 저장할 수 있는 저장 공간이어야 함

  ```java
  int i = 0;
  3 = i + 3; // 에러. lvalue가 저장 공간이 x
  i + 3 = i; // 에러. lvalue의 연산 결과가 리터럴
  
  final int MAX = 3; // 상수가 됨
  MAX = 10; // 에러. 상수에 새로운 값 저장 불가능
  ```



#### 복합 대입 연산자

> 대입 연산자와 다른 연산자를 하나로 축약

- i += 3;
  - (i = i+3과 같음)
- i += (10+j)
- 위 두 케이스를 기억해두면 모두 이해 가능
