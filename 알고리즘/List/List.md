# 알고리즘

> 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
>
> 컴퓨터가 어던 일을 수행하기 위한 단계적 방법



## 알고리즘의 표현

- Pseudocode(의사코드, 슈도코드)

![의사코드](List.assets/%EC%9D%98%EC%82%AC%EC%BD%94%EB%93%9C.PNG)

- 순서도

![순서도](List.assets/%EC%88%9C%EC%84%9C%EB%8F%84.PNG)



## 좋은 알고리즘의 조건

- 정확성 : 얼마나 정확하게 동작하는가
- 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
  - 시간 복잡도 : 실제 걸리는 시간을 측정, 실행되는 명령문의 개수를 계산
    - 빅-오(O) 표기법 : 가장 큰 영향력을 주는 n에 대한 항만을 표시(계수는 생략)
- 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
- 단순성 : 얼마나 단순한가
- 최적성 : 더 이상 개선할 여지없이 최적화되었는가



## 배열

> 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
>
> 변수들을 배열로 바꾸어 사용하는 것



- 장점
  - 여러 개의 변수가 필요할 때 효율적
  - 하나의 선언을 통해 둘 이상의 변수 선언 가능
  - 다수의 변수로는 하기 힘든 작업을 쉽게 함




## 정렬

> 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순), 혹은 그 반대의 순서대로 재배열하는 것



- 종류
  - 버블 정렬
  - 카운팅 정렬
  - 선택 정렬
  - 퀵 정렬
  - 삽입 정렬
  - 병합 정렬




#### 버블 정렬

> 인접한 두개의 원소를 비교하며 자리를 계속 교환하는 방식

- 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하며 맨 마지막자리까지 이동
- 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬
- 교환하며 자리를 이동하는 모습이 물 위로 올라오는 거품 모양과 같다하여 버블 정렬
- 시간 복잡도 : O(n<sup>2</sup> )
- 비교와 교환



- 예제 : [55, 7, 78, 12, 42] 버블 정렬

```pseudocode
BubbleSort(a, N)
	for i : N-1 -> 1
		for j : 0 -> i-1
			if a[j] > a[j+1]
				a[j] <-> a[j+1]
```

```python
def BubbleSort(a, N):
    for i in range(N-1, 0, -1):
        for j in range(i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
```



#### 카운팅 정렬

> 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다
- 시간 복잡도 : O(n + k)
  - n == 리스트 길이, k == 정수의 최댓값
- 비교환 방식



- 예제 : [0, 4, 1, 3, 1, 2, 4, 1] 카운팅 정렬

1. Data에서 각 항목들의 발생 회수를 세고, 카운트 배열 counts에 저장
2. 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 누적 분포의 형태로 조정
3. 뒤에서부터 counts[data[j]]를 감소시키고 temp[counts[data[j]]에 data[j]를 삽입 *반복

![카운팅정렬](List.assets/%EC%B9%B4%EC%9A%B4%ED%8C%85%EC%A0%95%EB%A0%AC.PNG)

- 코드

```python
def counting_sort(data, temp, k):
    counts = [0] * (k+1)
    
    for i in range(0, len(data)):
        counts[data[i]] += 1
        
    for i in range(1, len(counts)):
        counts[i] += counts[i-1]
    
    for i in range(len(b)-1, -1, -1):
        counts[data[i]] -= 1
        temp[counts[data[j]]] = data[j]
```



## Baby-gin game

- 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때 3장의 카드가 연속적인 번호를 갖는 경우 run, 동일한 번호를 갖는 경우 triplet
- 6장의 카드가 run과 triplet로만 구성된 경우를 baby-gin이라고 부른다
- 6자리 수를 입력 받아 baby-gin 여부를 판단



#### 완전 검색

- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인
- 수행 속도는 느리지만, 해답을 찾지 못할 확률이 적음
- 우선 완전 검색으로 접근하여 해답 도출 후, 성능 개선을 위해 다른 알고리즘 사용하여 확인하는 것이 바람직
- baby-gin game의 경우를 예시로 들면
  - 6개의 숫자로 만들 수 잇는 모든 숫자 나열(순열)을 구하여 앞뒤 3자리를 잘라 run과 triplet 여부를 테스트하는 방법이 완전 검색



#### 탐욕(Greedy) 알고리즘

- 최적의 해를 구하는데 사용되는 근시안적인 방법
- 결정하는 순간 최적이라고 생각되는 것을 선택해 나가는 방식
- 최종적인 해답을 만들었다고 하여 그것이 최적이라는 보장이 없다.
- 일반적으로 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근
- 동작과정
  - 해 선택 : 현재 상태에서 최적 해를 구한 뒤 부분해집합에 추가
  - 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지 확인, 문제 제약 조건 위반 않는지 검사
  - 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지 확인, 해가 완성되지 않았다면 1부터 다시
- baby-gin game의 경우를 예시로 들면
  -  대충 생각해서 앞뒤 3자리씩 끊어서 run과 triplet을 확인하는 방법을 고려할 수 있지만 123123과 같은 경우 실패할 수 있음 => 유의 필요



#### 옳게 된 Baby-gin 풀이

```python
T = int(input())
for tc in range(1, T+1):
    num = int(input())
    c = [0]*12
    for i in range(6):
        c[num % 10] += 1
        num //= 10
 
    i = 0
    tri = 0
    runn = 0
    while i < 10:
        if c[i] >= 3:
            tri += 1
            c[i] -= 3
            continue            
        if c[i] > 0 and c[i+1] > 0 and c[i+2] > 0:
            runn += 1
            c[i] -= 1
            c[i+1] -= 1
            c[i+2] -= 1
            continue            
        i += 1
    
    if tri + runn == 2:
        result = 'Baby Gin'
        
    else:
        result = 'Lose'
        
    print(f'#{tc} {result}')
```

